<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<!-- SECTION A: Branding (title) -->
<title>Loomabelle — Embroidery Maker</title>
<style>
/* ===== SECTION B: Theme (colors, spacing) ===== */
:root{
  --bg:#0b0c10; --ink:#e9ecf1; --muted:#aab2bf; --line:#1f2330; --brand:#6b4eff;
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--ink);
     font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
.hero{padding:28px 16px;text-align:center;font-weight:800;
      font-size:42px;background:var(--brand)}
.wrap{max-width:1100px;margin:18px auto;padding:0 16px}
.panel{background:rgba(255,255,255,.05);border:1px solid var(--line);
       border-radius:14px;padding:14px}
.controls{display:flex;flex-wrap:wrap;gap:10px;align-items:end}
.controls input[type="number"],.controls input[type="range"],.controls select{
  background:#11131a;color:var(--ink);border:1px solid var(--line);
  border-radius:10px;padding:6px 10px
}
button,.btn{padding:10px 14px;border-radius:10px;border:1px solid var(--line);
  background:#1a1f2b;color:var(--ink);text-decoration:none;cursor:pointer;
  font-weight:600}
button:disabled,.btn.disabled{opacity:.6;cursor:not-allowed}
.grid{display:grid;grid-template-columns:1.1fr .9fr;gap:16px;margin-top:14px}
@media(max-width:900px){.grid{grid-template-columns:1fr}}
.frame{border:1px dashed #2b3142;border-radius:12px;background:#0e1320;
       padding:10px;position:relative;overflow:hidden}
canvas{max-width:100%;display:block}
.tools{display:flex;gap:10px;align-items:center;margin-top:8px;flex-wrap:wrap}
.status{margin:6px 0 0;color:var(--muted)}
.foot{border-top:1px solid var(--line);margin-top:24px;padding:14px 16px;
      text-align:center;color:var(--muted)}
.tabbar{display:flex;gap:10px;margin-bottom:10px}
.tab{padding:10px 14px;border-radius:10px;border:1px solid var(--line);
     background:#141a2a;cursor:pointer}
.tab.active{background:#1f2740;border-color:#3b4360}
.hidden{display:none}
.pbar{width:100%;height:10px;background:#111522;border:1px solid #243;
      border-radius:999px;overflow:hidden}
.pbar>span{display:block;height:100%;
  background:linear-gradient(90deg,#5e8bff,#8f67ff);width:0%}
.color-row{display:flex;gap:6px;flex-wrap:wrap}
.color-row input[type="color"]{width:38px;height:32px;border:1px solid #333;
  border-radius:6px;background:#000;padding:0}
.small{font-size:13px;color:var(--muted)}
.tag{padding:4px 8px;border:1px solid var(--line);border-radius:999px;
     background:#121523}
.overlay{position:absolute;inset:10px;display:flex;align-items:center;
  justify-content:center;color:#9fb0ff;background:
  repeating-linear-gradient(45deg,#151a28 0,#151a28 10px,#0f1420 10px,#0f1420 20px);
  border-radius:8px;text-align:center;line-height:1.3}

/* ===== SECTION B: Debug Log UI (added) ===== */
.log {
  max-height: 180px;
  overflow: auto;
  font: 12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  background: #0c1220;
  border: 1px solid var(--line);
  border-radius: 10px;
  padding: 8px;
}
.log .row { margin: 0; white-space: pre-wrap; }
.log .ts { color: #8893a7; margin-right: 6px; }
.log .info { color: #cfe0ff; }
.log .warn { color: #ffd589; }
.log .error { color: #ff9b9b; }
</style>
</head>
<body>

<!-- SECTION A: Branding (header text) -->
<header class="hero">Loomabelle</header>

<main class="wrap">
  <!-- SECTION C: Tabs -->
  <div class="tabbar">
    <div class="tab active" id="tabUpload">Upload</div>
    <div class="tab" id="tabDraw">Draw</div>
  </div>

  <!-- Upload controls -->
  <section class="panel" id="panelUpload">
    <div class="controls">
      <input id="file" type="file" accept="image/*"/>

      <!-- SECTION D: Hoop options -->
      <label>Hoop
        <select id="hoop">
          <option value="4x4">4×4 (100×100mm)</option>
          <option value="5x7">5×7 (130×180mm)</option>
        </select>
      </label>

      <!-- SECTION E: Color count limit (client‑side safe range) -->
      <label>Colors (≤6) <input id="colors" type="number" min="2" max="6" value="4"/></label>

      <label class="tag"><input id="autoColors" type="checkbox" checked/> Auto colors</label>
      <div id="manualColors" class="color-row hidden"></div>

      <label class="tag"><input id="autoMode" type="checkbox" checked/> Auto embroider</label>

      <!-- SECTION F: Advanced options (hidden if Auto embroider) -->
      <div id="adv" class="controls">
        <label><input id="removeBg" type="checkbox" checked/> Remove background</label>
        <label><input id="outline" type="checkbox" checked/> Outline (satin)</label>
        <label>Fill angle° <input id="angle" type="number" value="45"/></label>
        <label>Density (mm) <input id="density" type="number" step="0.05" value="0.40"/></label>
        <label>Size (% hoop) <input id="sizePct" type="range" min="20" max="100" value="80"/></label>
        <span id="sizeOut" class="tag">80%</span>
      </div>

      <button id="process" disabled>Process</button>
      <a id="download" class="btn disabled" download="design.dst" href="#">Download .DST</a>
      <a id="downloadPalette" class="btn disabled" download="palette.txt" href="#">Palette (.txt)</a>
    </div>

    <!-- Progress + Status -->
    <div class="pbar" style="margin-top:10px"><span id="bar"></span></div>
    <p id="status" class="status">Upload a JPG/PNG/HEIC to begin.</p>

    <!-- ===== SECTION G: Debug Log UI (added) ===== -->
    <div class="tools" style="margin-top:10px">
      <button id="logClear">Clear log</button>
      <span class="small">Debug log (client‑side)</span>
    </div>
    <div id="log" class="log" aria-live="polite"></div>
  </section>

  <!-- Draw tab (simple handwriting) -->
  <section class="panel hidden" id="panelDraw">
    <div class="controls">
      <span class="tag">Handwriting canvas</span>
      <label>Brush <input id="dBrush" type="range" min="2" max="40" value="10"/></label>
      <label>Color <input id="dColor" type="color" value="#000000"/></label>
      <button id="dClear">Clear</button>
      <button id="dUse">Use for Embroidery</button>
      <span class="small">Tip: write big, high contrast.</span>
    </div>
    <div class="frame">
      <canvas id="draw" width="900" height="600" style="touch-action:none;background:#fff"></canvas>
    </div>
  </section>

  <section class="grid">
    <div class="panel">
      <h3>Preview (with hoop)</h3>
      <div class="frame"><canvas id="preview" width="720" height="520"></canvas></div>
      <p class="status">Rounded rectangle = hoop bounds.</p>
    </div>

    <div class="panel">
      <h3>Notes</h3>
      <ul>
        <li>Best with logo‑style art (3–6 colors).</li>
        <li>Auto mode: outline + hatch fill; manual shows more options.</li>
        <li>Use “Refine subject” if auto selection misses details.</li>
      </ul>
    </div>
  </section>

  <!-- SECTION R: Refinement (hidden by default) -->
  <section class="panel">
    <label class="tag">
      <input id="refineToggle" type="checkbox"/>
      Refine subject (show painting tools)
    </label>
    <div id="refineBox" class="hidden" style="margin-top:10px">
      <div class="frame">
        <div id="paintOverlay" class="overlay">
          Upload an image, then click <b>Auto‑select</b> or <b>Select subject</b> to paint.
        </div>
        <canvas id="paint"></canvas>
      </div>
      <div class="tools">
        <button id="autoMask" disabled>✨ Auto‑select</button>
        <label class="tag"><input id="smartAI" type="checkbox"/> Smart subject (AI, ~15 MB)</label>
        <button id="selectToggle" disabled>✍️ Select subject</button>
        <label>Brush <input id="brush" type="range" min="6" max="60" value="26"/></label>
        <label><input id="eraser" type="checkbox"/> Erase</label>
        <button id="clearMask" disabled>Clear</button>
        <span class="small">Outside the painted area is ignored.</span>
      </div>
    </div>
  </section>
</main>

<!-- SECTION A: Branding (footer) -->
<footer class="foot">© <span id="year"></span> Loomabelle</footer>

<!-- SECTION H: External libs -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
/* ========= UTILITIES ========= */
/* SECTION I: Helpers */
const $=s=>document.querySelector(s); $('#year').textContent=new Date().getFullYear();
const _statusEl = ()=>$('#status');
const _barEl = ()=>$('#bar');
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const hexToRgb=h=>{const m=h.replace('#','');return [parseInt(m.slice(0,2),16),parseInt(m.slice(2,4),16),parseInt(m.slice(4,6),16)]};
const rgbToHex=([r,g,b])=>'#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('');
const bump=p=>{const b=_barEl(); if(b) b.style.width=p+'%';};
const hasAny=mask=>{if(!mask) return false; for(let i=0;i<mask.length;i++) if(mask[i]) return true; return false;};
const cvReady=()=>new Promise(res=>{if(window.cv&&cv.Mat)res();else{const t=setInterval(()=>{if(window.cv&&cv.Mat){clearInterval(t);res();}},50);}});

// setStatus that also logs (actual log helpers defined later)
function setStatus(msg, cls=''){ const el=_statusEl(); if(el){ el.textContent=msg; el.className='status '+cls; } if(window.log){ log(msg, cls==='error'?'error':(cls==='warn'?'warn':'info')); }}

/* ========= TABS ========= */
const tabUpload=$('#tabUpload'), tabDraw=$('#tabDraw'), panelUpload=$('#panelUpload'), panelDraw=$('#panelDraw');
tabUpload.onclick=()=>{tabUpload.classList.add('active');tabDraw.classList.remove('active');panelUpload.classList.remove('hidden');panelDraw.classList.add('hidden');};
tabDraw.onclick=()=>{tabDraw.classList.add('active');tabUpload.classList.remove('active');panelDraw.classList.remove('hidden');panelUpload.classList.add('hidden');};

/* ========= DRAW CANVAS ========= */
const drawCv=$('#draw'), dctx=drawCv.getContext('2d',{willReadFrequently:true});
function dXY(e){const r=drawCv.getBoundingClientRect();const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left;const y=(e.touches?e.touches[0].clientY:e.clientY)-r.top;return [x,y];}
let drawing=false; dctx.lineCap='round'; dctx.lineJoin='round'; dctx.lineWidth=10; dctx.strokeStyle='#000';
drawCv.addEventListener('mousedown',e=>{drawing=true;const [x,y]=dXY(e);dctx.beginPath();dctx.moveTo(x,y)});
drawCv.addEventListener('mousemove',e=>{if(!drawing)return;const [x,y]=dXY(e);dctx.lineTo(x,y);dctx.stroke()});
window.addEventListener('mouseup',()=>drawing=false);
drawCv.addEventListener('touchstart',e=>{drawing=true;const [x,y]=dXY(e);dctx.beginPath();dctx.moveTo(x,y);e.preventDefault()},{passive:false});
drawCv.addEventListener('touchmove',e=>{if(!drawing)return;const [x,y]=dXY(e);dctx.lineTo(x,y);dctx.stroke();e.preventDefault()},{passive:false});
window.addEventListener('touchend',()=>drawing=false);
$('#dBrush').oninput=e=>{dctx.lineWidth=+e.target.value}; $('#dColor').oninput=e=>{dctx.strokeStyle=e.target.value};
$('#dClear').onclick=()=>{dctx.fillStyle='#fff';dctx.fillRect(0,0,drawCv.width,drawCv.height);dctx.fillStyle='#000'}; $('#dClear').click();
$('#dUse').onclick=()=>{work.width=drawCv.width;work.height=drawCv.height;wctx.clearRect(0,0,work.width,work.height);wctx.drawImage(drawCv,0,0);afterImageReady();setStatus('Drawing ready. Paint subject or Process.','ok');};

/* ========= COLOR PICKERS ========= */
function rebuildColorPickers(seed){
  const k=clamp(+$('#colors').value||4,2,6);
  const cont=$('#manualColors'); cont.innerHTML='';
  const palette = seed?.length ? seed : ['#000000','#ffffff','#ff0000','#00ff00','#0000ff','#ffff00'].slice(0,k);
  for(let i=0;i<k;i++){const inp=document.createElement('input');inp.type='color';inp.value=palette[i]||'#888888';cont.appendChild(inp);}
}
$('#colors').addEventListener('input',()=>rebuildColorPickers());
$('#autoColors').addEventListener('change',()=>{
  $('#manualColors').classList.toggle('hidden',$('#autoColors').checked);
  if(!$('#autoColors').checked) suggestPaletteToPickers();
});
function sampleDominant(canvas,maxK=6){
  const W=canvas.width,H=canvas.height,ctx=canvas.getContext('2d'); const step=Math.max(1,Math.floor(Math.sqrt((W*H)/20000)));
  const pts=[],dat=ctx.getImageData(0,0,W,H).data;
  for(let y=0;y<H;y+=step) for(let x=0;x<W;x+=step){const i=(y*W+x)*4; pts.push([dat[i],dat[i+1],dat[i+2]]);}
  const k=maxK, centers=[pts[Math.floor(Math.random()*pts.length)]];
  while(centers.length<k){let best=null,bd=-1;for(const p of pts){let d=1e9;for(const c of centers){const dd=(p[0]-c[0])**2+(p[1]-c[1])**2+(p[2]-c[2])**2;if(dd<d)d=dd;} if(d>bd){bd=d;best=p;}} centers.push(best.slice());}
  for(let it=0;it<6;it++){const sum=Array.from({length:k},()=>[0,0,0,0]);
    for(const p of pts){let bi=0,bd=1e12;for(let i=0;i<k;i++){const c=centers[i];const d=(p[0]-c[0])**2+(p[1]-c[1])**2+(p[2]-c[2])**2;if(d<bd){bd=d;bi=i;}} sum[bi][0]+=p[0];sum[bi][1]+=p[1];sum[bi][2]+=p[2];sum[bi][3]++}
    for(let i=0;i<k;i++){const s=sum[i]; if(s[3]) centers[i]=[s[0]/s[3]|0,s[1]/s[3]|0,s[2]/s[3]|0];}
  }
  const uniq=[]; for(const c of centers){if(!uniq.some(u=>Math.hypot(u[0]-c[0],u[1]-c[1],u[2]-c[2])<18)) uniq.push(c);}
  return uniq.sort((a,b)=>(0.2126*a[0]+0.7152*a[1]+0.0722*a[2])-(0.2126*b[0]+0.7152*b[1]+0.0722*b[2]));
}
function suggestPaletteToPickers(){
  if(!work.width){rebuildColorPickers();return;}
  const seed = sampleDominant(work,6).slice(0,clamp(+$('#colors').value||4,2,6)).map(rgbToHex);
  rebuildColorPickers(seed);
}

/* ========= HEIC SUPPORT ========= */
async function heicToJpeg(file){
  if(!window.heic2any){
    const s=document.createElement('script'); s.src='https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js';
    await new Promise((res,rej)=>{s.onload=res;s.onerror=rej;document.head.appendChild(s);});
  }
  const out=await window.heic2any({blob:file,toType:'image/jpeg',quality:0.92});
  const b=Array.isArray(out)?out[0]:out;
  return new File([b],(file.name||'image').replace(/\.\w+$/,'')+'.jpg',{type:'image/jpeg'});
}
function loadImageFromFile(file){return new Promise((resolve,reject)=>{const url=URL.createObjectURL(file);const im=new Image();im.onload=()=>{URL.revokeObjectURL(url);resolve(im)};im.onerror=reject;im.src=url;});}

/* ========= WORKING CANVASES ========= */
const work=document.createElement('canvas'), wctx=work.getContext('2d',{willReadFrequently:true});
const paint=$('#paint'), pctx=paint.getContext('2d',{willReadFrequently:true});
const overlay=$('#paintOverlay');
let userMask=null, painting=false;
function ensureMask(){ if(!userMask) userMask=new Uint8Array(paint.width*paint.height); }
function redrawPaint(){
  overlay?.classList.add('hidden');
  pctx.clearRect(0,0,paint.width,paint.height);
  if (work.width) pctx.drawImage(work,0,0,paint.width,paint.height);
  if(!userMask) return;
  const W=paint.width,H=paint.height,imgD=pctx.createImageData(W,H);
  for(let i=0;i<W*H;i++){ if(userMask[i]){imgD.data[i*4]=255;imgD.data[i*4+3]=80;} }
  pctx.putImageData(imgD,0,0);
}
function toCanvasXY(e){const r=paint.getBoundingClientRect();const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left;const y=(e.touches?e.touches[0].clientY:e.clientY)-r.top;return [Math.round(x*(paint.width/r.width)),Math.round(y*(paint.height/r.height))];}
function stamp(cx,cy,rad,on){ensureMask();const W=paint.width,H=paint.height,r2=rad*rad;
  for(let y=Math.max(0,cy-rad);y<Math.min(H,cy+rad);y++){const dy=y-cy;for(let x=Math.max(0,cx-rad);x<Math.min(W,cx+rad);x++){const dx=x-cx;if(dx*dx+dy*dy<=r2)userMask[y*W+x]=on?1:0;}}
  redrawPaint();}
function startPaint(e){if(selectToggle.dataset.active!=='1')return;painting=true;const [x,y]=toCanvasXY(e);stamp(x,y,+brushRange.value,!eraser.checked);e.preventDefault();}
function movePaint(e){if(!painting)return;const [x,y]=toCanvasXY(e);stamp(x,y,+brushRange.value,!eraser.checked);e.preventDefault();}
function endPaint(){painting=false;}
paint.addEventListener('mousedown',startPaint);paint.addEventListener('mousemove',movePaint);window.addEventListener('mouseup',endPaint);
paint.addEventListener('touchstart',startPaint,{passive:false});paint.addEventListener('touchmove',movePaint,{passive:false});window.addEventListener('touchend',endPaint);

/* ========= SUBJECT UI ========= */
const brushRange=$('#brush'), eraser=$('#eraser'), selectToggle=$('#selectToggle'), clearMaskBtn=$('#clearMask'), autoMaskBtn=$('#autoMask');
selectToggle.onclick=()=>{if(selectToggle.dataset.active==='1'){selectToggle.dataset.active='0';selectToggle.textContent='✍️ Select subject';}else{selectToggle.dataset.active='1';selectToggle.textContent='✅ Painting (drag)';}};
clearMaskBtn.onclick=()=>{if(userMask){userMask.fill(0);redrawPaint();}};

/* Show/hide refine tools */
$('#refineToggle').onchange = ()=> { $('#refineBox').classList.toggle('hidden', !$('#refineToggle').checked); };

/* ========= MODE VISIBILITY ========= */
function applyModeVisibility(){ $('#adv').style.display=$('#autoMode').checked?'none':'flex'; }
$('#autoMode').addEventListener('change',applyModeVisibility); applyModeVisibility();

/* ========= SIZE (% HOOP) LABEL ========= */
const sizePctRange=$('#sizePct'), sizeOut=$('#sizeOut'); sizeOut.textContent=sizePctRange.value+'%';
sizePctRange.oninput=()=>sizeOut.textContent=sizePctRange.value+'%';

/* ========= PREVIEW CANVAS ========= */
const preview=$('#preview'), gPrev=preview.getContext('2d');

/* ========= FILE LOAD ========= */
const fileInput=$('#file'), processBtn=$('#process'), dlDst=$('#download'), dlPal=$('#downloadPalette');
fileInput.onchange=async()=>{
  const f=fileInput.files?.[0]; if(!f) return;
  try{
    setStatus('Loading image…'); bump(5); log('File selected: '+(f.name||'(blob)'));
    let chosen=f; const n=(f.name||'').toLowerCase(), t=(f.type||'').toLowerCase();
    if(t.includes('heic')||t.includes('heif')||n.endsWith('.heic')||n.endsWith('.heif')){
      setStatus('Converting HEIC to JPEG…'); bump(10); chosen=await heicToJpeg(f); log('HEIC converted to JPEG');
    }
    const im=await loadImageFromFile(chosen);
    const K=clamp(+$('#colors').value||4,2,6);
    const maxLong=(K>4)?900:1100; // keep memory sane on phones
    const s=Math.min(1,maxLong/Math.max(im.width,im.height));
    work.width=Math.round(im.width*s); work.height=Math.round(im.height*s);
    wctx.clearRect(0,0,work.width,work.height); wctx.drawImage(im,0,0,work.width,work.height);

    paint.width=work.width; paint.height=work.height; userMask=new Uint8Array(work.width*work.height);
    redrawPaint(); processBtn.disabled=false; selectToggle.disabled=false; clearMaskBtn.disabled=false; autoMaskBtn.disabled=false;
    dlDst.classList.add('disabled'); dlPal.classList.add('disabled');
    if(!$('#autoColors').checked) suggestPaletteToPickers();
    setStatus(`Image ready (${work.width}×${work.height}). Refine subject if needed, then Process.`,'ok'); bump(12);
  }catch(e){logError(e,'FILE LOAD'); setStatus('Could not read image. Try a JPG/PNG.','error');}
};

/* ========= AI SEGMENTER (optional) ========= */
let deeplabModel = null;
async function loadDeeplab(){
  if (deeplabModel) return deeplabModel;
  setStatus('Loading AI model (first use)…'); bump(8);
  await new Promise((res,rej)=>{const s=document.createElement('script');s.src='https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js';s.onload=res;s.onerror=rej;document.head.appendChild(s);});
  await new Promise((res,rej)=>{const s=document.createElement('script');s.src='https://cdn.jsdelivr.net/npm/@tensorflow-models/deeplab@1.4.0/dist/deeplab.min.js';s.onload=res;s.onerror=rej;document.head.appendChild(s);});
  deeplabModel = await deeplab.load({base:'mobilenetv2', quantizationBytes:2});
  log('TF.js + DeepLab loaded');
  return deeplabModel;
}
async function segmentWithDeeplab(canvas){
  const model = await loadDeeplab();
  const tmp = document.createElement('canvas');
  const s = Math.min(513/Math.max(canvas.width,canvas.height), 1);
  tmp.width = Math.max(1, Math.round(canvas.width*s));
  tmp.height = Math.max(1, Math.round(canvas.height*s));
  tmp.getContext('2d').drawImage(canvas,0,0,tmp.width,tmp.height);
  const {segmentationMap} = await model.segment(tmp);
  const W=canvas.width,H=canvas.height;
  const up = new Uint8Array(W*H);
  for (let y=0;y<H;y++){
    const yy = Math.min(tmp.height-1, Math.round(y*s));
    for (let x=0;x<W;x++){
      const xx = Math.min(tmp.width-1, Math.round(x*s));
      const cls = segmentationMap[yy*tmp.width+xx];
      up[y*W+x] = (cls!==0) ? 1 : 0; // non‑background
    }
  }
  return up;
}

/* ========= GRABCUT (improved) ========= */
async function autoSubjectMaskGrabCut(){
  const W=work.width,H=work.height; if(!W) return null;
  await cvReady();
  try{
    const rgba = cv.imread(work);
    const rgb  = new cv.Mat(); cv.cvtColor(rgba, rgb, cv.COLOR_RGBA2RGB);
    const sm   = new cv.Mat(); cv.bilateralFilter(rgb, sm, 7, 75, 75);

    const mask = new cv.Mat.zeros(H, W, cv.CV_8U);
    const edges = new cv.Mat(); cv.Canny(sm, edges, 50, 150);
    let minx=W, miny=H, maxx=0, maxy=0;
    for (let y=0;y<H;y++) for (let x=0;x<W;x++){
      if (edges.ucharPtr(y,x)[0]>0){ if (x<minx) minx=x; if (y<miny) miny=y; if (x>maxx) maxx=x; if (y>maxy) maxy=y; }
    }
    if (maxx-minx<10 || maxy-miny<10){ minx=W*0.15|0; miny=H*0.15|0; maxx=W*0.85|0; maxy=H*0.85|0; }
    const rect = new cv.Rect(Math.max(0,minx-10), Math.max(0,miny-10), Math.min(W-1,maxx+10)-Math.max(0,minx-10), Math.min(H-1,maxy+10)-Math.max(0,miny-10));
    const bgd = new cv.Mat(), fgd = new cv.Mat();
    const painted = hasAny(userMask);
    if (painted){
      for (let y=0;y<H;y++) for (let x=0;x<W;x++)
        if (userMask[y*W+x]) mask.ucharPtr(y,x)[0] = cv.GC_FGD;
    }
    cv.grabCut(sm, mask, rect, bgd, fgd, 3, painted ? cv.GC_INIT_WITH_MASK : cv.GC_INIT_WITH_RECT);

    const out = new Uint8Array(W*H);
    for (let y=0;y<H;y++) for (let x=0;x<W;x++){
      const v = mask.ucharPtr(y,x)[0];
      out[y*W+x] = (v===cv.GC_FGD || v===cv.GC_PR_FGD) ? 1 : 0;
    }
    rgba.delete(); rgb.delete(); sm.delete(); edges.delete(); mask.delete(); bgd.delete(); fgd.delete();
    return hasAny(out) ? out : null;
  }catch(err){
    logError(err,'GRABCUT');
    const all=new Uint8Array(W*H); all.fill(1); return all;
  }
}

/* ========= Auto‑select handler (AI optional) ========= */
$('#autoMask').onclick = async ()=>{
  setStatus('Selecting subject…'); bump(15);
  let m = null;
  try{
    if ($('#smartAI').checked){
      log('AI segment: DeepLab'); m = await segmentWithDeeplab(work);
    }
  }catch(e){ logError(e,'AI SEGMENT'); }
  if (!m) { log('AI not used or failed; falling back to GrabCut'); m = await autoSubjectMaskGrabCut(); }
  if (m && hasAny(m)) { userMask = m; redrawPaint(); selectToggle.dataset.active='0'; selectToggle.textContent='✍️ Select subject'; setStatus('Subject selected. You can refine by painting.','ok'); }
  else { setStatus('Could not find a subject. Try painting a rough area.','error'); }
};

/* ========= QUANTIZATION (Worker with fallback) ========= */
function medianCutQuantize(imgData,k,mask){
  const W=imgData.width,H=imgData.height,data=imgData.data;
  const pts=[]; for(let i=0;i<W*H;i++){ if(mask&&mask[i]===0) continue; const j=i*4; pts.push([data[j],data[j+1],data[j+2]]); }
  if(pts.length===0) return {indexed:new Uint8Array(W*H).fill(255),palette:[],W,H};
  function splitBox(lo,hi){
    let rmin=255,rmax=0,gmin=255,gmax=0,bmin=255,bmax=0;
    for(let i=lo;i<hi;i++){const p=pts[i];
      if(p[0]<rmin)rmin=p[0]; if(p[0]>rmax)rmax=p[0];
      if(p[1]<gmin)gmin=p[1]; if(p[1]>gmax)gmax=p[1];
      if(p[2]<bmin)bmin=p[2]; if(p[2]>bmax)bmax=p[2];
    }
    const dr=rmax-rmin,dg=gmax-gmin,db=bmax-bmin;
    const ch=(dr>=dg&&dr>=db)?0:(dg>=db?1:2);
    pts.slice(lo,hi).sort((a,b)=>a[ch]-b[ch]).forEach((p,i)=>{pts[lo+i]=p});
    const mid=(lo+hi)>>1; return [[lo,mid],[mid,hi]];
  }
  const ranges=[[0,pts.length]];
  while(ranges.length<k){const r=ranges.shift(); if(!r||r[1]-r[0]<2)break;
    const s=splitBox(r[0],r[1]); ranges.push(s[0],s[1]); ranges.sort((A,B)=>(B[1]-B[0])-(A[1]-A[0]));}
  const palette=ranges.map(([lo,hi])=>{
    let rs=0,gs=0,bs=0,c=0; for(let i=lo;i<hi;i++){const p=pts[i]; rs+=p[0];gs+=p[1];bs+=p[2];c++; }
    if(!c)c=1; return [ (rs/c)|0, (gs/c)|0, (bs/c)|0 ];
  });
  const indexed=new Uint8Array(W*H).fill(255);
  for(let i=0;i<W*H;i++){
    if(mask&&mask[i]===0){indexed[i]=255; continue;}
    const j=i*4; const r=data[j],g=data[j+1],b=data[j+2]; let bi=0,bd=1e12;
    for(let c=0;c<palette.length;c++){const pr=palette[c][0],pg=palette[c][1],pb=palette[c][2]; const d=(r-pr)**2+(g-pg)**2+(b-pb)**2; if(d<bd){bd=d;bi=c;}}
    indexed[i]=bi;
  }
  return {indexed,palette,W,H};
}
async function quantizeSafe(imgData,k,mask){
  if(!window._qWorkerURL){
    window._qWorkerURL=URL.createObjectURL(new Blob([`
      self.onmessage=(e)=>{const {img,k,mask}=e.data; const W=img.width,H=img.height,data=new Uint8ClampedArray(img.data);
        const pts=[]; for(let i=0;i<W*H;i++){ if(mask&&mask[i]===0) continue; const j=i*4; pts.push([data[j],data[j+1],data[j+2]]);}
        if(pts.length===0){ self.postMessage({err:'empty'}); return;}
        function split(lo,hi){let rmin=255,rmax=0,gmin=255,gmax=0,bmin=255,bmax=0;
          for(let i=lo;i<hi;i++){const p=pts[i]; if(p[0]<rmin)rmin=p[0]; if(p[0]>rmax)rmax=p[0];
            if(p[1]<gmin)gmin=p[1]; if(p[1]>gmax)gmax=p[1]; if(p[2]<bmin)bmin=p[2]; if(p[2]>bmax)bmax=p[2];}
          const dr=rmax-rmin,dg=gmax-gmin,db=bmax-bmin; const ch=(dr>=dg&&dr>=db)?0:(dg>=db?1:2);
          pts.slice(lo,hi).sort((a,b)=>a[ch]-b[ch]).forEach((p,i)=>{pts[lo+i]=p}); const mid=(lo+hi)>>1; return [[lo,mid],[mid,hi]];
        }
        const ranges=[[0,pts.length]]; while(ranges.length<k){const r=ranges.shift(); if(!r||r[1]-r[0]<2)break;
          const s=split(r[0],r[1]); ranges.push(s[0],s[1]); ranges.sort((A,B)=>(B[1]-B[0])-(A[1]-A[0]));}
        const palette=ranges.map(([lo,hi])=>{let rs=0,gs=0,bs=0,c=0; for(let i=lo;i<hi;i++){const p=pts[i]; rs+=p[0]; gs+=p[1]; bs+=p[2]; c++; } if(!c)c=1; return [rs/c|0,gs/c|0,bs/c|0];});
        const indexed=new Uint8Array(W*H).fill(255);
        for(let i=0;i<W*H;i++){ if(mask&&mask[i]===0){indexed[i]=255; continue;}
          const j=i*4; const r=data[j],g=data[j+1],b=data[j+2]; let bi=0,bd=1e12;
          for(let c=0;c<palette.length;c++){const pr=palette[c][0],pg=palette[c][1],pb=palette[c][2]; const d=(r-pr)**2+(g-pg)**2+(b-pb)**2; if(d<bd){bd=d;bi=c;}}
          indexed[i]=bi;} self.postMessage({indexed,palette,W,H});};`],{type:'text/javascript'}));
  }
  try{
    const worker=new Worker(window._qWorkerURL);
    const p=new Promise((res,rej)=>{worker.onmessage=e=>{if(e.data.err) rej(e.data.err); else res(e.data)}; worker.onerror=rej;});
    worker.postMessage({img:imgData,k,mask}); const out=await p; worker.terminate(); return out;
  }catch(err){ logError(err,'WORKER'); return medianCutQuantize(imgData,k,mask); }
}

/* ========= PRE‑PROCESS (contrast enhance) ========= */
function preprocessForQuantize(srcCanvas){
  const W=srcCanvas.width,H=srcCanvas.height;
  const mRGBA = cv.imread(srcCanvas);
  const mBGR  = new cv.Mat(); cv.cvtColor(mRGBA, mBGR, cv.COLOR_RGBA2BGR);
  const mLAB  = new cv.Mat(); cv.cvtColor(mBGR, mLAB, cv.COLOR_BGR2Lab);
  const lab = new cv.MatVector(); cv.split(mLAB, lab);
  const clahe = new cv.CLAHE(2.0, new cv.Size(8,8));
  clahe.apply(lab.get(0), lab.get(0));
  cv.merge(lab, mLAB); lab.delete(); clahe.delete();
  const mOut  = new cv.Mat(); cv.cvtColor(mLAB, mOut, cv.COLOR_Lab2RGBA);
  const canvas = document.createElement('canvas'); canvas.width=W; canvas.height=H;
  cv.imshow(canvas, mOut);
  mRGBA.delete(); mBGR.delete(); mLAB.delete(); mOut.delete();
  return canvas;
}

/* ========= STITCH PLANNER ========= */
function erodeMask(mask,W,H,rPx){if(rPx<=0)return mask;let cur=mask;
  for(let t=0;t<rPx;t++){const out=new Uint8Array(W*H);
    for(let y=1;y<H-1;y++){const row=y*W; for(let x=1;x<W-1;x++){if(!cur[row+x])continue;let keep=true;
      for(let dy=-1;dy<=1&&keep;dy++)for(let dx=-1;dx<=1;dx++)if(!cur[(y+dy)*W+(x+dx)]){keep=false;break;}
      if(keep)out[row+x]=1;}} cur=out;}
  return cur;}
function marchingSquaresOutline(mask,W,H){let sx=-1,sy=-1;for(let y=1;y<H-1&&sy<0;y++)for(let x=1;x<W-1;x++)if(mask[y*W+x]&&!mask[y*W+(x-1)]){sx=x;sy=y;break}
  if(sx<0)return[];const pts=[];let x=sx,y=sy;const max=W*H*4;
  for(let step=0;step<max;step++){pts.push([x,y]);const a=mask[(y-1)*W+(x-1)]?1:0,b=mask[(y-1)*W+x]?1:0,c=mask[y*W+(x-1)]?1:0,d=mask[y*W+x]?1:0;const code=(a<<3)|(b<<2)|(c<<1)|d;
    if(code===0||code===1||code===3||code===9||code===11){x++;} else if(code===2||code===6||code===7||code===14){y++;} else if(code===4||code===12||code===13||code===8){x--;} else {y--;}
    if(x===sx&&y===sy&&pts.length>12)break;x=Math.max(1,Math.min(W-2,x));y=Math.max(1,Math.min(H-2,y));}
  const out=[];for(let i=0;i<pts.length;i+=2)out.push(pts[i]);return out;}
function hatchSegmentsFromMask(mask,W,H,bbox,angle,spacingPx,stepPx){
  const segs=[];const dir=[Math.cos(angle*Math.PI/180),Math.sin(angle*Math.PI/180)], nrm=[-dir[1],dir[0]];
  const bw=bbox.maxx-bbox.minx,bh=bbox.maxy-bbox.miny;const cx=(bbox.minx+bbox.maxx)/2,cy=(bbox.miny+bbox.maxy)/2;
  const half=Math.hypot(bw,bh)*0.75;const range=Math.ceil(Math.hypot(bw,bh)/spacingPx)+2;
  for(let k=-range;k<=range;k++){const off=k*spacingPx,px=cx+nrm[0]*off,py=cy+nrm[1]*off;let start=null;
    for(let s=-half;s<=half;s+=stepPx){const x=Math.round(px+dir[0]*s),y=Math.round(py+dir[1]*s);
      const inside=(x>=0&&y>=0&&x<W&&y<H)?mask[y*W+x]===1:false;
      if(inside&&!start)start=[x,y];
      if((!inside||s>=half)&&start){const end=inside?[x,y]:[Math.round(px+dir[0]*(s-stepPx)),Math.round(py+dir[1]*(s-stepPx))];
        if(Math.hypot(end[0]-start[0],end[1]-start[1])>=2)segs.push([start,end]);start=null;}}}
  return segs;}
function lineStitch(out,aMM,bMM,maxStepMM){const len=Math.hypot(bMM[0]-aMM[0],bMM[1]-aMM[1]);const steps=Math.max(1,Math.ceil(len/maxStepMM));
  for(let i=1;i<=steps;i++){const t=i/steps;out.push({x:aMM[0]+(bMM[0]-aMM[0])*t,y:aMM[1]+(bMM[1]-aMM[1])*t});}}
function runningOutline(stitches,ptsMM,maxStepMM=3){if(!ptsMM.length)return;stitches.push({x:ptsMM[0][0],y:ptsMM[0][1],jump:true});
  for(let i=1;i<=ptsMM.length;i++){const a=ptsMM[i-1],b=ptsMM[i%ptsMM.length];lineStitch(stitches,a,b,maxStepMM);}}
function satinOutline(stitches,ptsMM,widthMM=0.8,stepMM=0.6){if(ptsMM.length<3)return;const half=widthMM/2;let left=true;
  stitches.push({x:ptsMM[0][0],y:ptsMM[0][1],jump:true});
  for(let i=1;i<ptsMM.length;i++){const a=ptsMM[i-1],b=ptsMM[i];const dx=b[0]-a[0],dy=b[1]-a[1];const len=Math.hypot(dx,dy)||1;const nx=-dy/len,ny=dx/len;const seg=Math.max(1,Math.ceil(len/stepMM));
    for(let k=0;k<seg;k++){const t=k/seg;const cx=a[0]+dx*t,cy=a[1]+dy*t;const off=left?half:-half;stitches.push({x:cx+nx*off,y:cy+ny*off});left=!left;}}}

/* ========= PREVIEW & EXPORT ========= */
const HOOP_MM={ '4x4':{w:100,h:100}, '5x7':{w:130,h:180} };
function drawPreviewColored(plan,hoop,sizePct){
  const ctx=gPrev,W=preview.width,H=preview.height;ctx.clearRect(0,0,W,H);
  const pad=20,asp=hoop.h/hoop.w;let hoopW=W-2*pad,hoopH=hoopW*asp;if(hoopH>H-2*pad){hoopH=H-2*pad;hoopW=hoopH/asp}
  const hx=(W-hoopW)/2,hy=(H-hoopH)/2,r=12;
  ctx.fillStyle='#111824';ctx.fillRect(0,0,W,H);ctx.strokeStyle='#334';ctx.lineWidth=2;ctx.beginPath();
  const rr=(x,y,w,h,rad)=>{ctx.moveTo(x+rad,y);ctx.arcTo(x+w,y,x+w,y+h,rad);ctx.arcTo(x+w,y+h,x,y+h,rad);ctx.arcTo(x,y+h,x,y,rad);ctx.arcTo(x,y,x+w,y,rad);};
  rr(hx,hy,hoopW,hoopH,r);ctx.stroke();
  let minx=Infinity,miny=Infinity,maxx=-Infinity,maxy=-Infinity;
  for(const s of plan.stitches){if(s.end||s.colorChange)continue;minx=Math.min(minx,s.x);miny=Math.min(miny,s.y);maxx=Math.max(maxx,s.x);maxy=Math.max(maxy,s.y);}
  const scale=(sizePct/100)*Math.min(hoopW/hoop.w,hoopH/hoop.h), ox=W/2-(minx+maxx)/2*scale, oy=H/2-(miny+maxy)/2*scale;
  let last=null,ci=0; const toCss=rgb=>`rgb(${rgb[0]},${rgb[1]},${rgb[2]})`; ctx.lineWidth=1.2; ctx.strokeStyle=toCss(plan.colors[0]||[220,220,220]);
  for(const s of plan.stitches){
    if(s.colorChange){last=null;ci=Math.min(ci+1,plan.colors.length-1);ctx.strokeStyle=toCss(plan.colors[ci]||[200,200,200]);continue;}
    if(s.end)break; if(s.jump){last={x:s.x,y:s.y};continue;} if(!last){last={x:s.x,y:s.y};continue;}
    ctx.beginPath();ctx.moveTo(ox+last.x*scale,oy+last.y*scale);ctx.lineTo(ox+s.x*scale,oy+s.y*scale);ctx.stroke();last={x:s.x,y:s.y};
  }
}
function writeDST(plan){
  const recs=[];let lx=0,ly=0;const to10th=mm=>Math.round(mm*10),clamp121=v=>Math.max(-121,Math.min(121,v));
  for(const s of plan.stitches){
    if(s.end){recs.push(0x00,0x00,0xF3);break;}
    if(s.colorChange){recs.push(0x00,0x00,0xC3);continue;}
    const dx=clamp121(to10th(s.x-lx)),dy=clamp121(to10th(s.y-ly));lx=s.x;ly=s.y;
    const [b1,b2,b3]=pack(dx,dy,!!s.jump);recs.push(b1,b2,b3);
  }
  const header=new Uint8Array(512).fill(0x20),put=(t,o)=>{for(let i=0;i<t.length;i++)header[o+i]=t.charCodeAt(i);};
  put('LA:LOOMABELLE\n',0);
  put(`ST:${String(Math.floor(recs.length/3)).padStart(7,' ')}`,11);
  put(`CO:${String(Math.max(1,plan.colors.length)).padStart(7,' ')}`,24);
  put('+X  100\n-Y  100\n',52); put('AX+ 0\nAY+ 0\nMX+ 0\nMY+ 0\n',80);
  put('PD:******\n',232);
  const out=new Uint8Array(512+recs.length+1); out.set(header,0); out.set(new Uint8Array(recs),512); out[512+recs.length]=0x1A; return out.buffer;
}
function pack(dx,dy,jump){let b1=0,b2=0,b3=0;const ax=Math.abs(dx),ay=Math.abs(dy);
  if(ax&1)b1|=1;if(ax&2)b1|=2;if(ax&4)b1|=4;if(ax&8)b2|=1;if(ax&16)b2|=2;if(ax&32)b2|=4;if(ax&64)b3|=1;
  if(ay&1)b1|=8;if(ay&2)b1|=16;if(ay&4)b1|=32;if(ay&8)b2|=8;if(ay&16)b2|=16;if(ay&32)b2|=32;if(ay&64)b3|=2;
  if(dx<0)b3|=0x20;if(dy<0)b3|=0x40;if(jump)b3|=0x10;return[b1,b2,b3]}

/* ========= SECTION L: Debug Log helpers ========= */
function nowTs(){ const d=new Date(); return d.toLocaleTimeString(); }
function log(msg,type='info'){
  const box = document.querySelector('#log');
  if(!box) return;
  const row = document.createElement('div');
  row.className = `row ${type}`;
  row.innerHTML = `<span class="ts">[${nowTs()}]</span> ${msg}`;
  box.appendChild(row);
  box.scrollTop = box.scrollHeight;
}
function logError(err, where=''){
  console.error(where || 'error', err);
  log(`${where ? where+': ' : ''}${err?.message || err}`, 'error');
  if(err?.stack) log(String(err.stack), 'error');
}
document.querySelector('#logClear')?.addEventListener('click', ()=> {
  const box=document.querySelector('#log'); if(box) box.innerHTML='';
});

/* ========= PROCESS HANDLER ========= */
const HOOP=HOOP_MM; const hoopSel=$('#hoop');
const sizePctEl=$('#sizePct'); const processBtnEl=$('#process');

// ===== SECTION N: Logged Process handler =====
processBtnEl.onclick = async ()=>{
  if(!work.width){ setStatus('No image loaded.','error'); log('Aborting: work canvas empty','error'); return; }

  processBtn.disabled = true;
  dlDst.classList.add('disabled');
  dlPal.classList.add('disabled');
  bump(0);
  log('=== PROCESS START ===');
  try{
    const auto = $('#autoMode').checked;
    const k = clamp(+$('#colors').value || 4, 2, 6);
    const fixedPalette = $('#autoColors').checked ? null :
      [...$('#manualColors').querySelectorAll('input[type="color"]')].slice(0,k).map(el=>hexToRgb(el.value));
    const hoop = HOOP[$('#hoop').value];

    const removeBg   = auto ? true : $('#removeBg').checked;
    const wantOutline= auto ? true : $('#outline').checked;
    const angleDeg   = auto ? 45   : (+$('#angle').value||45);
    const densityMM  = auto ? 0.40 : (+$('#density').value||0.40);
   