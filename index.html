<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Loomabelle</title>
<style>
  body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f5f5f5; }
  header { background: #673ab7; color: white; padding: 10px; text-align: center; font-size: 1.5em; }
  main { padding: 20px; }
  .controls { margin-bottom: 10px; }
  button { margin-right: 5px; padding: 6px 12px; }
  .status { margin: 10px 0; }
  .log { background: #111; color: #0f0; font-family: monospace; padding: 10px; height: 200px; overflow-y: auto; }
  canvas { max-width: 100%; border: 1px solid #ccc; background: white; }
  .tools { margin-top: 10px; }
</style>
</head>
<body>

<!-- SECTION A: Logo -->
<header>
  Loomabelle
</header>

<main>
  <div class="controls">
    <input type="file" id="fileInput" accept="image/*">
    <button id="processBtn" disabled>Process</button>
    <button id="downloadBtn" disabled>Download</button>
  </div>
  <p id="status" class="status">Upload a JPG/PNG to begin.</p>
  <canvas id="previewCanvas"></canvas>

  <!-- Debug tools -->
  <div class="tools">
    <button id="logClear">Clear log</button>
    <button id="envCheck">Run self-check</button>
    <span class="small">Debug log (client-side)</span>
  </div>
  <div id="log" class="log" aria-live="polite"></div>
</main>

<!-- OpenCV -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
const logEl = document.getElementById('log');
function log(msg, level='info'){
  const time = new Date().toISOString().split('T')[1].split('.')[0];
  logEl.innerHTML += `[${time}] ${msg}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}
function logError(err, ctx=''){
  log(`ERROR${ctx?` in ${ctx}`:''}: ${err.message || err}`, 'error');
  if(err.stack) log(err.stack, 'error');
}
function setStatus(msg, cls=''){
  const el = document.getElementById('status');
  el.textContent = msg;
  el.className = 'status ' + cls;
}

// Wait for OpenCV to be ready
function cvReady(){
  return new Promise((res, rej)=>{
    let attempts = 0;
    const check = ()=>{
      attempts++;
      if(window.cv && cv.Mat) return res();
      if(attempts > 100) return rej(new Error('OpenCV load timeout'));
      setTimeout(check, 50);
    };
    check();
  });
}

// ===== Global error capture =====
window.addEventListener('error', (e)=>{
  log(`Window error: ${e.message} @ ${e.filename}:${e.lineno}:${e.colno}`, 'error');
  if (e.error && e.error.stack) log(e.error.stack, 'error');
});
window.addEventListener('unhandledrejection', (e)=>{
  log(`Unhandled promise rejection: ${e.reason?.message || e.reason}`, 'error');
  if (e.reason?.stack) log(e.reason.stack, 'error');
});

// Self-check button
document.querySelector('#envCheck')?.addEventListener('click', async ()=>{
  log('=== SELF-CHECK START ===');
  try{
    log(`UserAgent: ${navigator.userAgent}`);
    log(`Cross-origin isolation: ${self.crossOriginIsolated ? 'yes' : 'no'}`);
    log('Checking OpenCV…');
    await cvReady();
    log(`cv.Mat OK. cv version: ${cv?.getBuildInformation ? 'has build info' : 'basic build'}`);
    const hasCLAHE = !!(cv.CLAHE && cv.Size);
    log(`CLAHE available: ${hasCLAHE}`);
    const c=document.createElement('canvas'); c.width=c.height=64;
    const ctx=c.getContext('2d'); ctx.fillStyle='#f00'; ctx.fillRect(0,0,64,64);
    const m=cv.imread(c); const g=new cv.Mat(); cv.cvtColor(m,g,cv.COLOR_RGBA2GRAY);
    log(`OpenCV ops OK (gray rows: ${g.rows}, cols: ${g.cols})`);
    m.delete(); g.delete();
    let workerOK = true;
    try{
      const url=URL.createObjectURL(new Blob(['onmessage=(e)=>postMessage(e.data+1)'],{type:'text/javascript'}));
      const w=new Worker(url); const p=new Promise((res,rej)=>{w.onmessage=e=>res(e.data); w.onerror=rej;});
      w.postMessage(41); const ans=await p; w.terminate(); URL.revokeObjectURL(url);
      workerOK = (ans===42);
    }catch(_){ workerOK = false; }
    log(`Blob worker: ${workerOK ? 'OK' : 'BLOCKED'}`);
  }catch(err){ logError(err,'SELF-CHECK'); }
  log('=== SELF-CHECK END ===');
});

document.getElementById('logClear').addEventListener('click', ()=> logEl.textContent='');

// Safe preprocess with fallback
function preprocessForQuantize(srcCanvas){
  const W=srcCanvas.width,H=srcCanvas.height;
  const out=document.createElement('canvas'); out.width=W; out.height=H;
  try{
    if (!cv || !cv.Mat) throw new Error('OpenCV not ready');
    const mRGBA=cv.imread(srcCanvas);
    const mBGR=new cv.Mat(); cv.cvtColor(mRGBA,mBGR,cv.COLOR_RGBA2BGR);
    const mLAB=new cv.Mat(); cv.cvtColor(mBGR,mLAB,cv.COLOR_BGR2Lab);
    if (!cv.CLAHE || !cv.Size) throw new Error('CLAHE not available in this build');
    const lab=new cv.MatVector(); cv.split(mLAB,lab);
    const clahe=new cv.CLAHE(2.0,new cv.Size(8,8));
    clahe.apply(lab.get(0),lab.get(0));
    cv.merge(lab,mLAB); lab.delete(); clahe.delete();
    const mOut=new cv.Mat(); cv.cvtColor(mLAB,mOut,cv.COLOR_Lab2RGBA);
    cv.imshow(out,mOut);
    mRGBA.delete(); mBGR.delete(); mLAB.delete(); mOut.delete();
    log('Preprocess: CLAHE applied');
    return out;
  }catch(err){
    log(`Preprocess fallback: ${err.message}`,'warn');
    const ctx=out.getContext('2d',{willReadFrequently:true});
    ctx.drawImage(srcCanvas,0,0);
    const id=ctx.getImageData(0,0,W,H); const d=id.data;
    const gamma=0.9; const ig=1/gamma;
    for(let i=0;i<d.length;i+=4){
      d[i]=255*Math.pow(d[i]/255,ig);
      d[i+1]=255*Math.pow(d[i+1]/255,ig);
      d[i+2]=255*Math.pow(d[i+2]/255,ig);
    }
    ctx.putImageData(id,0,0);
    try{
      if ('filter' in ctx){ ctx.filter='blur(0.3px)'; ctx.drawImage(out,0,0); ctx.filter='none'; }
    }catch(_){}
    return out;
  }
}

// Elements
const fileInput=document.getElementById('fileInput');
const processBtn=document.getElementById('processBtn');
const downloadBtn=document.getElementById('downloadBtn');
const previewCanvas=document.getElementById('previewCanvas');
let workCanvas=null;

// File upload
fileInput.addEventListener('change', e=>{
  const file=e.target.files[0];
  if(!file) return;
  const img=new Image();
  img.onload=()=>{
    previewCanvas.width=img.width;
    previewCanvas.height=img.height;
    const ctx=previewCanvas.getContext('2d');
    ctx.drawImage(img,0,0);
    workCanvas=previewCanvas;
    processBtn.disabled=false;
    setStatus('Image loaded.');
    log(`Loaded image ${file.name} (${img.width}x${img.height})`);
  };
  img.onerror=()=>{ setStatus('Error loading image','error'); };
  img.src=URL.createObjectURL(file);
});

// Process
processBtn.addEventListener('click', async ()=>{
  if(!workCanvas?.width){
    setStatus('No image loaded.','error');
    log('Aborting: work canvas empty','error');
    return;
  }
  try{
    setStatus('Processing…');
    log('Waiting for OpenCV (cvReady)…');
    await cvReady();
    const processed=preprocessForQuantize(workCanvas);
    previewCanvas.getContext('2d').drawImage(processed,0,0);
    downloadBtn.disabled=false;
    setStatus('Processing complete.');
    log('Processing complete.');
  }catch(err){
    setStatus('Processing failed.','error');
    logError(err,'PROCESS');
  }
});

// Download
downloadBtn.addEventListener('click', ()=>{
  const link=document.createElement('a');
  link.download='output.png';
  link.href=previewCanvas.toDataURL();
  link.click();
});
</script>

</body>
</html>