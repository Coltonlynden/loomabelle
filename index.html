<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Loomabelle — Embroidery Maker</title>
<style>
:root{--bg:#0b0c10;--ink:#e9ecf1;--muted:#aab2bf;--line:#1f2330;--brand:#6b4eff}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
.hero{padding:28px 16px;text-align:center;font-weight:800;font-size:42px;background:var(--brand)}
.wrap{max-width:1100px;margin:18px auto;padding:0 16px}
.panel{background:rgba(255,255,255,.05);border:1px solid var(--line);border-radius:14px;padding:14px}
.controls{display:flex;flex-wrap:wrap;gap:10px;align-items:end}
.controls input[type="number"],.controls input[type="range"],.controls select{background:#11131a;color:var(--ink);border:1px solid var(--line);border-radius:10px;padding:6px 10px}
button,.btn{padding:10px 14px;border-radius:10px;border:1px solid var(--line);background:#1a1f2b;color:var(--ink);text-decoration:none;cursor:pointer;font-weight:600}
button:disabled,.btn.disabled{opacity:.6;cursor:not-allowed}
.grid{display:grid;grid-template-columns:1.1fr .9fr;gap:16px;margin-top:14px}
@media(max-width:900px){.grid{grid-template-columns:1fr}}
.frame{border:1px dashed #2b3142;border-radius:12px;background:#0e1320;padding:10px;position:relative;overflow:hidden}
canvas{max-width:100%;display:block}
.tools{display:flex;gap:10px;align-items:center;margin-top:8px;flex-wrap:wrap}
.status{margin:6px 0 0;color:var(--muted)}
.foot{border-top:1px solid var(--line);margin-top:24px;padding:14px 16px;text-align:center;color:var(--muted)}
.tabbar{display:flex;gap:10px;margin-bottom:10px}
.tab{padding:10px 14px;border-radius:10px;border:1px solid var(--line);background:#141a2a;cursor:pointer}
.tab.active{background:#1f2740;border-color:#3b4360}
.hidden{display:none}
.pbar{width:100%;height:10px;background:#111522;border:1px solid #243;border-radius:999px;overflow:hidden}
.pbar>span{display:block;height:100%;background:linear-gradient(90deg,#5e8bff,#8f67ff);width:0%}
.color-row{display:flex;gap:6px;flex-wrap:wrap}
.color-row input[type="color"]{width:38px;height:32px;border:1px solid #333;border-radius:6px;background:#000;padding:0}
.small{font-size:13px;color:var(--muted)}
.tag{padding:4px 8px;border:1px solid var(--line);border-radius:999px;background:#121523}
.overlay{position:absolute;inset:10px;display:flex;align-items:center;justify-content:center;color:#9fb0ff;background:repeating-linear-gradient(45deg,#151a28 0,#151a28 10px,#0f1420 10px,#0f1420 20px);border-radius:8px}
</style>
</head>
<body>
<header class="hero">Loomabelle</header>

<main class="wrap">

  <div class="tabbar">
    <div class="tab active" id="tabUpload">Upload</div>
    <div class="tab" id="tabDraw">Draw</div>
  </div>

  <!-- Upload controls -->
  <section class="panel" id="panelUpload">
    <div class="controls">
      <input id="file" type="file" accept="image/*"/>
      <label>Hoop
        <select id="hoop">
          <option value="4x4">4×4 (100×100mm)</option>
          <option value="5x7">5×7 (130×180mm)</option>
        </select>
      </label>
      <label>Colors (≤6) <input id="colors" type="number" min="2" max="6" value="4"/></label>
      <label class="tag"><input id="autoColors" type="checkbox" checked/> Auto colors</label>
      <div id="manualColors" class="color-row hidden"></div>

      <label class="tag"><input id="autoMode" type="checkbox" checked/> Auto embroider</label>
      <div id="adv" class="controls">
        <label><input id="removeBg" type="checkbox" checked/> Remove background</label>
        <label><input id="outline" type="checkbox" checked/> Outline (satin)</label>
        <label>Fill angle° <input id="angle" type="number" value="45"/></label>
        <label>Density (mm) <input id="density" type="number" step="0.05" value="0.40"/></label>
        <label>Size (% hoop) <input id="sizePct" type="range" min="20" max="100" value="80"/></label>
        <span id="sizeOut" class="tag">80%</span>
      </div>

      <button id="process" disabled>Process</button>
      <a id="download" class="btn disabled" download="design.dst" href="#">Download .DST</a>
      <a id="downloadPalette" class="btn disabled" download="palette.txt" href="#">Palette (.txt)</a>
    </div>

    <div class="pbar" style="margin-top:10px"><span id="bar"></span></div>
    <p id="status" class="status">Upload a JPG/PNG/HEIC to begin.</p>
  </section>

  <!-- Draw (handwriting) -->
  <section class="panel hidden" id="panelDraw">
    <div class="controls">
      <span class="tag">Handwriting canvas</span>
      <label>Brush <input id="dBrush" type="range" min="2" max="40" value="10"/></label>
      <label>Color <input id="dColor" type="color" value="#000000"/></label>
      <button id="dClear">Clear</button>
      <button id="dUse">Use for Embroidery</button>
      <span class="small">Tip: write big, high contrast.</span>
    </div>
    <div class="frame"><canvas id="draw" width="900" height="600" style="touch-action:none;background:#fff"></canvas></div>
  </section>

  <section class="grid">
    <div class="panel">
      <h3>Subject (paint to select)</h3>
      <div class="frame">
        <div id="paintOverlay" class="overlay">Upload an image, then tap <b style="margin:0 6px">Auto‑select Subject</b> or <b style="margin:0 6px">Select subject</b> to paint.</div>
        <canvas id="paint"></canvas>
      </div>
      <div class="tools">
        <button id="autoMask" disabled>✨ Auto‑select Subject</button>
        <button id="selectToggle" disabled>✍️ Select subject</button>
        <label>Brush <input id="brush" type="range" min="6" max="60" value="26"/></label>
        <label><input id="eraser" type="checkbox"/> Erase</label>
        <button id="clearMask" disabled>Clear</button>
        <span class="small">Outside the painted area is ignored.</span>
      </div>
    </div>

    <div class="panel">
      <h3>Preview (with hoop)</h3>
      <div class="frame"><canvas id="preview" width="720" height="520"></canvas></div>
      <p class="status">Rounded rectangle = hoop bounds.</p>
    </div>
  </section>

</main>
<footer class="foot">© <span id="year"></span> Loomabelle</footer>

<!-- OpenCV.js (WASM) -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>

<script>
/* ===== tiny helpers ===== */
const $=s=>document.querySelector(s); $('#year').textContent=new Date().getFullYear();
const setStatus=(m,cls='')=>{const el=$('#status'); el.textContent=m; el.className='status '+cls;};
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
const hexToRgb=h=>{const m=h.replace('#','');return [parseInt(m.slice(0,2),16),parseInt(m.slice(2,4),16),parseInt(m.slice(4,6),16)]};
const rgbToHex=([r,g,b])=>'#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('');
const maskActive=mask=>!!mask && mask.some?.(Boolean) || (!!mask && (()=>{for(let i=0;i<mask.length;i++) if(mask[i]) return true; return false;})());
const bar=$('#bar'); const bump=p=>bar.style.width=p+'%';

/* ===== tabs ===== */
const tabUpload=$('#tabUpload'), tabDraw=$('#tabDraw'), panelUpload=$('#panelUpload'), panelDraw=$('#panelDraw');
tabUpload.onclick=()=>{tabUpload.classList.add('active');tabDraw.classList.remove('active');panelUpload.classList.remove('hidden');panelDraw.classList.add('hidden');};
tabDraw.onclick=()=>{tabDraw.classList.add('active');tabUpload.classList.remove('active');panelDraw.classList.remove('hidden');panelUpload.classList.add('hidden');};

/* ===== DOM els ===== */
const fileInput=$('#file'), processBtn=$('#process'), dlDst=$('#download'), dlPal=$('#downloadPalette');
const hoopSel=$('#hoop');const paint=$('#paint'), pctx=paint.getContext('2d',{willReadFrequently:true}); const overlay=$('#paintOverlay');
const brushRange=$('#brush'), eraser=$('#eraser'), selectToggle=$('#selectToggle'), clearMaskBtn=$('#clearMask'), autoMaskBtn=$('#autoMask');
const preview=$('#preview'), gPrev=preview.getContext('2d'); const sizePctRange=$('#sizePct'), sizeOut=$('#sizeOut'); sizeOut.textContent=sizePctRange.value+'%';
sizePctRange.oninput=()=>sizeOut.textContent=sizePctRange.value+'%';

/* ===== draw tab ===== */
const drawCv=$('#draw'), dctx=drawCv.getContext('2d',{willReadFrequently:true});
function dXY(e){const r=drawCv.getBoundingClientRect();const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left;const y=(e.touches?e.touches[0].clientY:e.clientY)-r.top;return [x,y];}
let drawing=false; dctx.lineCap='round'; dctx.lineJoin='round'; dctx.lineWidth=10; dctx.strokeStyle='#000';
drawCv.addEventListener('mousedown',e=>{drawing=true;const [x,y]=dXY(e);dctx.beginPath();dctx.moveTo(x,y)}); 
drawCv.addEventListener('mousemove',e=>{if(!drawing)return;const [x,y]=dXY(e);dctx.lineTo(x,y);dctx.stroke()}); 
window.addEventListener('mouseup',()=>drawing=false);
drawCv.addEventListener('touchstart',e=>{drawing=true;const [x,y]=dXY(e);dctx.beginPath();dctx.moveTo(x,y);e.preventDefault()},{passive:false});
drawCv.addEventListener('touchmove',e=>{if(!drawing)return;const [x,y]=dXY(e);dctx.lineTo(x,y);dctx.stroke();e.preventDefault()},{passive:false});
window.addEventListener('touchend',()=>drawing=false);
$('#dBrush').oninput=e=>{dctx.lineWidth=+e.target.value}; $('#dColor').oninput=e=>{dctx.strokeStyle=e.target.value};
$('#dClear').onclick=()=>{dctx.fillStyle='#fff';dctx.fillRect(0,0,drawCv.width,drawCv.height);dctx.fillStyle='#000'}; $('#dClear').click();
$('#dUse').onclick=()=>{work.width=drawCv.width;work.height=drawCv.height;wctx.clearRect(0,0,work.width,work.height);wctx.drawImage(drawCv,0,0);afterImageReady();setStatus('Drawing ready. Paint subject or Process.','ok');};

/* ===== color UI ===== */
function rebuildColorPickers(seed){
  const k=clamp(+$('#colors').value||4,2,6);
  const cont=$('#manualColors'); cont.innerHTML='';
  const palette = seed?.length ? seed : ['#000000','#ffffff','#ff0000','#00ff00','#0000ff','#ffff00'].slice(0,k);
  for(let i=0;i<k;i++){const inp=document.createElement('input');inp.type='color';inp.value=palette[i]||'#888888';cont.appendChild(inp);}
}
$('#colors').addEventListener('input',()=>rebuildColorPickers());
$('#autoColors').addEventListener('change',()=>{$('#manualColors').classList.toggle('hidden',$('#autoColors').checked); if(!$('#autoColors').checked) suggestPaletteToPickers();});
function suggestPaletteToPickers(){
  if(!work.width){rebuildColorPickers();return;}
  const seed = sampleDominant(work,6).slice(0,clamp(+$('#colors').value||4,2,6)).map(rgbToHex);
  rebuildColorPickers(seed);
}

/* ===== heic ===== */
async function heicToJpeg(file){
  if(!window.heic2any){await new Promise((res,rej)=>{const s=document.createElement('script');s.src='https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js';s.onload=res;s.onerror=()=>rej(new Error('heic2any'));document.head.appendChild(s);});}
  const out=await window.heic2any({blob:file,toType:'image/jpeg',quality:0.92});const b=Array.isArray(out)?out[0]:out;
  return new File([b],(file.name||'image').replace(/\.\w+$/,'')+'.jpg',{type:'image/jpeg'});
}
function loadImageFromFile(file){return new Promise((resolve,reject)=>{const url=URL.createObjectURL(file);const im=new Image();im.onload=()=>{URL.revokeObjectURL(url);resolve(im)};im.onerror=reject;im.src=url;});}

/* ===== working canvas ===== */
const work=document.createElement('canvas'), wctx=work.getContext('2d',{willReadFrequently:true});
let userMask=null, painting=false;
function ensureMask(){ if(!userMask) userMask=new Uint8Array(paint.width*paint.height); }
function redrawPaint(){
  overlay.classList.add('hidden');
  pctx.clearRect(0,0,paint.width,paint.height);
  pctx.drawImage(work,0,0,paint.width,paint.height);
  if(!userMask) return;
  const W=paint.width,H=paint.height,imgD=pctx.createImageData(W,H);
  for(let i=0;i<W*H;i++){ if(userMask[i]){imgD.data[i*4]=255;imgD.data[i*4+3]=80;} }
  pctx.putImageData(imgD,0,0);
}
function toCanvasXY(e){const r=paint.getBoundingClientRect();const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left;const y=(e.touches?e.touches[0].clientY:e.clientY)-r.top;return [Math.round(x*(paint.width/r.width)),Math.round(y*(paint.height/r.height))];}
function stamp(cx,cy,rad,on){ensureMask();const W=paint.width,H=paint.height,r2=rad*rad;
  for(let y=Math.max(0,cy-rad);y<Math.min(H,cy+rad);y++){const dy=y-cy;for(let x=Math.max(0,cx-rad);x<Math.min(W,cx+rad);x++){const dx=x-cx;if(dx*dx+dy*dy<=r2)userMask[y*W+x]=on?1:0;}}
  redrawPaint();}
function startPaint(e){if(selectToggle.dataset.active!=='1')return;painting=true;const [x,y]=toCanvasXY(e);stamp(x,y,+brushRange.value,!eraser.checked);e.preventDefault();}
function movePaint(e){if(!painting)return;const [x,y]=toCanvasXY(e);stamp(x,y,+brushRange.value,!eraser.checked);e.preventDefault();}
function endPaint(){painting=false;}
paint.addEventListener('mousedown',startPaint);paint.addEventListener('mousemove',movePaint);window.addEventListener('mouseup',endPaint);
paint.addEventListener('touchstart',startPaint,{passive:false});paint.addEventListener('touchmove',movePaint,{passive:false});window.addEventListener('touchend',endPaint);
selectToggle.onclick=()=>{if(selectToggle.dataset.active==='1'){selectToggle.dataset.active='0';selectToggle.textContent='✍️ Select subject';}else{selectToggle.dataset.active='1';selectToggle.textContent='✅ Painting (drag)';}};
clearMaskBtn.onclick=()=>{if(userMask){userMask.fill(0);redrawPaint();}};

/* ===== auto/mode visibility ===== */
function applyModeVisibility(){ $('#adv').style.display=$('#autoMode').checked?'none':'flex'; }
$('#autoMode').addEventListener('change',applyModeVisibility); applyModeVisibility();

/* ===== image loading & scaling ===== */
fileInput.onchange=async()=>{
  const f=fileInput.files?.[0]; if(!f) return;
  try{
    setStatus('Loading image…'); bump(5);
    let chosen=f; const n=(f.name||'').toLowerCase(), t=(f.type||'').toLowerCase();
    if(t.includes('heic')||t.includes('heif')||n.endsWith('.heic')||n.endsWith('.heif')){setStatus('Converting HEIC to JPEG…');bump(10);chosen=await heicToJpeg(f);}
    const im=await loadImageFromFile(chosen);
    // downscale: long side max 1000 (≤6 colors)
    const K=clamp(+$('#colors').value||4,2,6);
    const maxLong= (K>4)? 900 : 1100;
    const s=Math.min(1, maxLong/Math.max(im.width,im.height));
    work.width=Math.round(im.width*s); work.height=Math.round(im.height*s);
    wctx.clearRect(0,0,work.width,work.height); wctx.drawImage(im,0,0,work.width,work.height);

    paint.width=work.width; paint.height=work.height; userMask=new Uint8Array(work.width*work.height);
    redrawPaint(); processBtn.disabled=false; selectToggle.disabled=false; clearMaskBtn.disabled=false; autoMaskBtn.disabled=false;
    dlDst.classList.add('disabled'); dlPal.classList.add('disabled');
    if(!$('#autoColors').checked) suggestPaletteToPickers();
    setStatus(`Image ready (${work.width}×${work.height}). Auto‑select or paint, then Process.`,'ok'); bump(12);
  }catch(e){console.error(e);setStatus('Could not read image. Try a JPG/PNG.','error');}
};

/* ===== simple dominant sampler (for manual palette seed) ===== */
function sampleDominant(canvas,maxK=6){
  const W=canvas.width,H=canvas.height,ctx=canvas.getContext('2d'); const step=Math.max(1,Math.floor(Math.sqrt((W*H)/20000)));
  const pts=[]; const dat=ctx.getImageData(0,0,W,H).data;
  for(let y=0;y<H;y+=step) for(let x=0;x<W;x+=step){const i=(y*W+x)*4; pts.push([dat[i],dat[i+1],dat[i+2]]);}
  // tiny kmeans++ init + few steps
  const k=maxK, centers=[pts[Math.floor(Math.random()*pts.length)]];
  while(centers.length<k){let best=null,bd=-1;for(const p of pts){let d=1e9;for(const c of centers){const dd=(p[0]-c[0])**2+(p[1]-c[1])**2+(p[2]-c[2])**2;if(dd<d)d=dd;} if(d>bd){bd=d;best=p;}} centers.push(best.slice());}
  for(let it=0;it<6;it++){const sum=Array.from({length:k},()=>[0,0,0,0]);
    for(const p of pts){let bi=0,bd=1e12;for(let i=0;i<k;i++){const c=centers[i];const d=(p[0]-c[0])**2+(p[1]-c[1])**2+(p[2]-c[2])**2;if(d<bd){bd=d;bi=i;}} sum[bi][0]+=p[0];sum[bi][1]+=p[1];sum[bi][2]+=p[2];sum[bi][3]++}
    for(let i=0;i<k;i++){const s=sum[i]; if(s[3]) centers[i]=[s[0]/s[3]|0,s[1]/s[3]|0,s[2]/s[3]|0];}
  }
  // unique-ish and sorted by luminance
  const uniq=[]; for(const c of centers){if(!uniq.some(u=>Math.hypot(u[0]-c[0],u[1]-c[1],u[2]-c[2])<18)) uniq.push(c);}
  return uniq.sort((a,b)=>(0.2126*a[0]+0.7152*a[1]+0.0722*a[2])-(0.2126*b[0]+0.7152*b[1]+0.0722*b[2]));
}

/* ===== OpenCV.js: GrabCut auto subject ===== */
function cvReady(){return new Promise(res=>{if(window.cv && cv.Mat) return res(); const t=setInterval(()=>{if(window.cv&&cv.Mat){clearInterval(t);res();}},50);});}
function autoSubjectMaskGrabCut(){
  // rectangle around center 70% as fallback; if userMask has paint, convert to GC_FGD
  const W=work.width,H=work.height; if(!W) return null;
  const src=cv.imread(work); const mask=new cv.Mat.zeros(H,W,cv.CV_8U);
  // seed: user strokes
  let painted=maskActive(userMask);
  if(painted){ for(let y=0;y<H;y++){for(let x=0;x<W;x++){ if(userMask[y*W+x]) mask.ucharPtr(y,x)[0]=cv.GC_FGD; }}}
  const rect = new cv.Rect(W*0.15|0,H*0.15|0,W*0.70|0,H*0.70|0);
  const bgdModel=new cv.Mat(), fgdModel=new cv.Mat();
  cv.grabCut(src, mask, rect, bgdModel, fgdModel, 3, painted? cv.GC_INIT_WITH_MASK : cv.GC_INIT_WITH_RECT);
  // result: 1 where FG/PR_FG
  const out=new Uint8Array(W*H);
  for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ const v=mask.ucharPtr(y,x)[0]; out[y*W+x]=(v===cv.GC_FGD||v===cv.GC_PR_FGD)?1:0; } }
  src.delete();mask.delete();bgdModel.delete();fgdModel.delete();
  return out;
}
autoMaskBtn.onclick=async()=>{await cvReady(); const m=autoSubjectMaskGrabCut(); if(!m) return; userMask=m; redrawPaint(); selectToggle.dataset.active='0'; selectToggle.textContent='✍️ Select subject'; };

/* ===== Web Worker (median-cut quantizer) ===== */
const workerURL=URL.createObjectURL(new Blob([`
self.onmessage = (e)=>{
  const {img,k,mask}=e.data; const W=img.width,H=img.height; const data=new Uint8ClampedArray(img.data);
  // collect pixels (respect mask if provided)
  const pts=[]; for(let i=0;i<W*H;i++){ if(mask && mask[i]===0) continue; const j=i*4; pts.push([data[j],data[j+1],data[j+2]]); }
  if(pts.length===0){ self.postMessage({err:'empty'}); return; }
  // median cut
  function box(pts,lo,hi){let rmin=255,rmax=0,gmin=255,gmax=0,bmin=255,bmax=0;
    for(let i=lo;i<hi;i++){const p=pts[i]; if(p[0]<rmin)rmin=p[0]; if(p[0]>rmax)rmax=p[0]; if(p[1]<gmin)gmin=p[1]; if(p[1]>gmax)gmax=p[1]; if(p[2]<bmin)bmin=p[2]; if(p[2]>bmax)bmax=p[2];}
    const dr=rmax-rmin,dg=gmax-gmin,db=bmax-bmin; const ch=(dr>=dg&&dr>=db)?0:(dg>=db?1:2); pts.slice(lo,hi).sort((a,b)=>a[ch]-b[ch]).forEach((p,i)=>{pts[lo+i]=p});
    const mid=(lo+hi)>>1; return [[lo,mid],[mid,hi]];
  }
  const ranges=[[0,pts.length]]; while(ranges.length<k){ let r=ranges.shift(); if(!r||r[1]-r[0]<2){break;} const s=box(pts,r[0],r[1]); ranges.push(s[0],s[1]); ranges.sort((A,B)=>(B[1]-B[0])-(A[1]-A[0])); }
  const palette=ranges.map(([lo,hi])=>{let rs=0,gs=0,bs=0,c=0; for(let i=lo;i<hi;i++){const p=pts[i];rs+=p[0];gs+=p[1];bs+=p[2];c++;} if(c===0)c=1; return [rs/c|0,gs/c|0,bs/c|0];});
  // map every pixel to nearest
  const indexed=new Uint8Array(W*H).fill(255);
  for(let i=0;i<W*H;i++){
    if(mask && mask[i]===0){indexed[i]=255; continue;}
    const j=i*4; const r=data[j],g=data[j+1],b=data[j+2]; let bi=0,bd=1e12;
    for(let c=0;c<palette.length;c++){const pr=palette[c][0],pg=palette[c][1],pb=palette[c][2]; const d=(r-pr)**2+(g-pg)**2+(b-pb)**2; if(d<bd){bd=d;bi=c;}}
    indexed[i]=bi;
  }
  self.postMessage({indexed,palette,W,H});
};`],{type:'text/javascript'}));

/* ===== stitch planning & preview ===== */
function erodeMask(mask,W,H,rPx){if(rPx<=0)return mask;let cur=mask;
  for(let t=0;t<rPx;t++){const out=new Uint8Array(W*H);
    for(let y=1;y<H-1;y++){const row=y*W;
      for(let x=1;x<W-1;x++){if(!cur[row+x])continue;let keep=true;
        for(let dy=-1;dy<=1&&keep;dy++)for(let dx=-1;dx<=1;dx++)if(!cur[(y+dy)*W+(x+dx)]){keep=false;break;}
        if(keep)out[row+x]=1;}}
    cur=out;} return cur;}
function marchingSquaresOutline(mask,W,H){let sx=-1,sy=-1;for(let y=1;y<H-1&&sy<0;y++)for(let x=1;x<W-1;x++)if(mask[y*W+x]&&!mask[y*W+(x-1)]){sx=x;sy=y;break}
  if(sx<0)return[];const pts=[];let x=sx,y=sy;const max=W*H*4;
  for(let step=0;step<max;step++){pts.push([x,y]);const a=mask[(y-1)*W+(x-1)]?1:0,b=mask[(y-1)*W+x]?1:0,c=mask[y*W+(x-1)]?1:0,d=mask[y*W+x]?1:0;const code=(a<<3)|(b<<2)|(c<<1)|d;
    if(code===0||code===1||code===3||code===9||code===11){x++;} else if(code===2||code===6||code===7||code===14){y++;} else if(code===4||code===12||code===13||code===8){x--;} else {y--;}
    if(x===sx&&y===sy&&pts.length>12)break;x=Math.max(1,Math.min(W-2,x));y=Math.max(1,Math.min(H-2,y));}
  const out=[];for(let i=0;i<pts.length;i+=2)out.push(pts[i]);return out;}
function hatchSegmentsFromMask(mask,W,H,bbox,angle,spacingPx,stepPx){
  const segs=[];const dir=[Math.cos(angle*Math.PI/180),Math.sin(angle*Math.PI/180)], nrm=[-dir[1],dir[0]];
  const bw=bbox.maxx-bbox.minx,bh=bbox.maxy-bbox.miny;const cx=(bbox.minx+bbox.maxx)/2,cy=(bbox.miny+bbox.maxy)/2;
  const half=Math.hypot(bw,bh)*0.75;const range=Math.ceil(Math.hypot(bw,bh)/spacingPx)+2;
  for(let k=-range;k<=range;k++){const off=k*spacingPx,px=cx+nrm[0]*off,py=cy+nrm[1]*off;let start=null;
    for(let s=-half;s<=half;s+=stepPx){const x=Math.round(px+dir[0]*s),y=Math.round(py+dir[1]*s);
      const inside=(x>=0&&y>=0&&x<W&&y<H)?mask[y*W+x]===1:false;
      if(inside&&!start)start=[x,y];
      if((!inside||s>=half)&&start){const end=inside?[x,y]:[Math.round(px+dir[0]*(s-stepPx)),Math.round(py+dir[1]*(s-stepPx))];
        if(Math.hypot(end[0]-start[0],end[1]-start[1])>=2)segs.push([start,end]);start=null;}}}
  return segs;}
function lineStitch(out,aMM,bMM,maxStepMM){const len=Math.hypot(bMM[0]-aMM[0],bMM[1]-aMM[1]);const steps=Math.max(1,Math.ceil(len/maxStepMM));
  for(let i=1;i<=steps;i++){const t=i/steps;out.push({x:aMM[0]+(bMM[0]-aMM[0])*t,y:aMM[1]+(bMM[1]-aMM[1])*t});}}
function runningOutline(stitches,ptsMM,maxStepMM=3){if(!ptsMM.length)return;stitches.push({x:ptsMM[0][0],y:ptsMM[0][1],jump:true});
  for(let i=1;i<=ptsMM.length;i++){const a=ptsMM[i-1],b=ptsMM[i%ptsMM.length];lineStitch(stitches,a,b,maxStepMM);}}
function satinOutline(stitches,ptsMM,widthMM=0.8,stepMM=0.6){if(ptsMM.length<3)return;const half=widthMM/2;let left=true;
  stitches.push({x:ptsMM[0][0],y:ptsMM[0][1],jump:true});
  for(let i=1;i<ptsMM.length;i++){const a=ptsMM[i-1],b=ptsMM[i];const dx=b[0]-a[0],dy=b[1]-a[1];const len=Math.hypot(dx,dy)||1;const nx=-dy/len,ny=dx/len;const seg=Math.max(1,Math.ceil(len/stepMM));
    for(let k=0;k<seg;k++){const t=k/seg;const cx=a[0]+dx*t,cy=a[1]+dy*t;const off=left?half:-half;stitches.push({x:cx+nx*off,y:cy+ny*off});left=!left;}}}
function drawPreviewColored(plan,hoop,sizePct){
  const ctx=gPrev,W=preview.width,H=preview.height;ctx.clearRect(0,0,W,H);
  const pad=20,asp=hoop.h/hoop.w;let hoopW=W-2*pad,hoopH=hoopW*asp;if(hoopH>H-2*pad){hoopH=H-2*pad;hoopW=hoopH/asp}
  const hx=(W-hoopW)/2,hy=(H-hoopH)/2,r=12;
  ctx.fillStyle='#111824';ctx.fillRect(0,0,W,H);ctx.strokeStyle='#334';ctx.lineWidth=2;ctx.beginPath();
  const rr=(x,y,w,h,rad)=>{ctx.moveTo(x+rad,y);ctx.arcTo(x+w,y,x+w,y+h,rad);ctx.arcTo(x+w,y+h,x,y+h,rad);ctx.arcTo(x,y+h,x,y,rad);ctx.arcTo(x,y,x+w,y,rad);};
  rr(hx,hy,hoopW,hoopH,r);ctx.stroke();
  let minx=Infinity,miny=Infinity,maxx=-Infinity,maxy=-Infinity;
  for(const s of plan.stitches){if(s.end||s.colorChange)continue;minx=Math.min(minx,s.x);miny=Math.min(miny,s.y);maxx=Math.max(maxx,s.x);maxy=Math.max(maxy,s.y);}
  const scale=(sizePct/100)*Math.min(hoopW/hoop.w,hoopH/hoop.h), ox=W/2-(minx+maxx)/2*scale, oy=H/2-(miny+maxy)/2*scale;
  let last=null,ci=0; const toCss=rgb=>`rgb(${rgb[0]},${rgb[1]},${rgb[2]})`; ctx.lineWidth=1.2; ctx.strokeStyle=toCss(plan.colors[0]||[220,220,220]);
  for(const s of plan.stitches){
    if(s.colorChange){last=null;ci=Math.min(ci+1,plan.colors.length-1);ctx.strokeStyle=toCss(plan.colors[ci]||[200,200,200]);continue;}
    if(s.end)break; if(s.jump){last={x:s.x,y:s.y};continue;} if(!last){last={x:s.x,y:s.y};continue;}
    ctx.beginPath();ctx.moveTo(ox+last.x*scale,oy+last.y*scale);ctx.lineTo(ox+s.x*scale,oy+s.y*scale);ctx.stroke();last={x:s.x,y:s.y};
  }
}
function writeDST(plan){
  const recs=[];let lx=0,ly=0;const to10th=mm=>Math.round(mm*10),clamp121=v=>Math.max(-121,Math.min(121,v));
  for(const s of plan.stitches){
    if(s.end){recs.push(0x00,0x00,0xF3);break;}
    if(s.colorChange){recs.push(0x00,0x00,0xC3);continue;}
    const dx=clamp121(to10th(s.x-lx)),dy=clamp121(to10th(s.y-ly));lx=s.x;ly=s.y;
    const [b1,b2,b3]=pack(dx,dy,!!s.jump);recs.push(b1,b2,b3);
  }
  const header=new Uint8Array(512).fill(0x20),put=(t,o)=>{for(let i=0;i<t.length;i++)header[o+i]=t.charCodeAt(i);};
  put('LA:LOOMABELLE\n',0); put(`ST:${String(Math.floor(recs.length/3)).padStart(7,' ')}`,11);
  put(`CO:${String(Math.max(1,plan.colors.length)).padStart(7,' ')}`,24); put('+X  100\n-Y  100\n',52);
  put('AX+ 0\nAY+ 0\nMX+ 0\nMY+ 0\n',80); put('PD:******\n',232);
  const out=new Uint8Array(512+recs.length+1); out.set(header,0); out.set(new Uint8Array(recs),512); out[512+recs.length]=0x1A; return out.buffer;
}
function pack(dx,dy,jump){let b1=0,b2=0,b3=0;const ax=Math.abs(dx),ay=Math.abs(dy);
  if(ax&1)b1|=1;if(ax&2)b1|=2;if(ax&4)b1|=4;if(ax&8)b2|=1;if(ax&16)b2|=2;if(ax&32)b2|=4;if(ax&64)b3|=1;
  if(ay&1)b1|=8;if(ay&2)b1|=16;if(ay&4)b1|=32;if(ay&8)b2|=8;if(ay&16)b2|=16;if(ay&32)b2|=32;if(ay&64)b3|=2;
  if(dx<0)b3|=0x20;if(dy<0)b3|=0x40;if(jump)b3|=0x10;return[b1,b2,b3]}

/* ===== processing ===== */
const HOOP_MM={ '4x4':{w:100,h:100}, '5x7':{w:130,h:180} };
const processBtnEl=$('#process');
processBtnEl.onclick=async()=>{
  if(!work.width) return;
  processBtn.disabled=true; dlDst.classList.add('disabled'); dlPal.classList.add('disabled'); setStatus('Processing…'); bump(3);

  const auto=$('#autoMode').checked, k=clamp(+$('#colors').value||4,2,6);
  const fixedPalette = $('#autoColors').checked ? null : [...$('#manualColors').querySelectorAll('input[type="color"]')].slice(0,k).map(el=>hexToRgb(el.value));
  const hoop=HOOP_MM[$('#hoop').value];
  const removeBg = auto ? true : $('#removeBg').checked;
  const wantOutline = auto ? true : $('#outline').checked;
  const angleDeg = auto ? 45 : (+$('#angle').value||45);
  const densityMM = auto ? 0.40 : (+$('#density').value||0.40);
  const sizePct = auto ? 80 : (+$('#sizePct').value||80);

  const W=work.width,H=work.height;
  try{
    await cvReady(); bump(8);
    // subject mask via GrabCut if requested or if user painted
    let activeMask = maskActive(userMask) || removeBg ? autoSubjectMaskGrabCut() : (maskActive(userMask)?userMask:null);
    if(activeMask && !maskActive(activeMask)) activeMask=null;

    // progressive preview: tiny pass (not exported)
    bump(12);
    const imgData=wctx.getImageData(0,0,W,H);
    const worker=new Worker(workerURL);
    const p1 = new Promise((res,rej)=>{worker.onmessage=e=>{if(e.data.err) rej(e.data.err); else res(e.data);}; worker.onerror=rej;});
    worker.postMessage({img:imgData,k,mask:activeMask});
    const {indexed,palette}=await p1; worker.terminate(); bump(40);

    if(!palette.length){ setStatus('No colors detected. Try different options.','error'); processBtn.disabled=false; return; }

    const masks=palette.map((_,ci)=>{const m=new Uint8Array(W*H); for(let i=0;i<W*H;i++) if(indexed[i]===ci) m[i]=1; return m;});
    // bbox of all masks
    const bbox=masks.reduce((b,m)=>{for(let y=0;y<H;y++){const row=y*W;for(let x=0;x<W;x++) if(m[row+x]){if(x<b.minx)b.minx=x;if(y<b.miny)b.miny=y;if(x>b.maxx)b.maxx=x;if(y>b.maxy)b.maxy=y;}} return b;},{minx:Infinity,miny:Infinity,maxx:-Infinity,maxy:-Infinity});
    if(!(bbox.maxx>bbox.minx && bbox.maxy>bbox.miny)){ setStatus('No solid areas found.','error'); processBtn.disabled=false; return; }

    bump(65);

    const bw=bbox.maxx-bbox.minx,bh=bbox.maxy-bbox.miny,cx=(bbox.minx+bbox.maxx)/2,cy=(bbox.miny+bbox.maxy)/2;
    const mmPerPx=Math.min(hoop.w/bw,hoop.h/bh)*(sizePct/100); const pxPerMM=1/mmPerPx;
    const spacingPx=Math.max(1,Math.round(densityMM*pxPerMM)); const stepPx=Math.max(1,Math.round(0.6*pxPerMM)); const insetPx=Math.max(1,Math.round(0.5*pxPerMM));

    const plan={stitches:[],colors: fixedPalette ? fixedPalette : palette.slice()};
    for(let ci=0;ci<masks.length;ci++){
      if(ci>0) plan.stitches.push({colorChange:true,x:0,y:0});
      const outlinePx=marchingSquaresOutline(masks[ci],W,H);
      const outlineMM=outlinePx.map(([x,y])=>[(x-cx)*mmPerPx,(y-cy)*mmPerPx]);
      runningOutline(plan.stitches,outlineMM,3);
      const inset=erodeMask(masks[ci],W,H,insetPx);
      const segs=hatchSegmentsFromMask(inset,W,H,bbox,angleDeg,spacingPx,stepPx);
      for(const [a,b] of segs){const sMM=[(a[0]-cx)*mmPerPx,(a[1]-cy)*mmPerPx], eMM=[(b[0]-cx)*mmPerPx,(b[1]-cy)*mmPerPx];
        plan.stitches.push({x:sMM[0],y:sMM[1],jump:true}); lineStitch(plan.stitches,sMM,eMM,7);}
      if(wantOutline && outlineMM.length>4) satinOutline(plan.stitches,outlineMM,0.8,0.6);
      bump(65+Math.round(30*(ci+1)/masks.length));
    }
    plan.stitches.push({end:true,x:0,y:0});

    drawPreviewColored(plan,hoop,sizePct);
    const dstBlob=new Blob([writeDST(plan)],{type:'application/octet-stream'}); dlDst.href=URL.createObjectURL(dstBlob); dlDst.classList.remove('disabled');
    const palText=plan.colors.map((rgb,i)=>`Color ${i+1}: rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`).join('\n');
    const palBlob=new Blob([palText],{type:'text/plain'}); dlPal.href=URL.createObjectURL(palBlob); dlPal.classList.remove('disabled');

    bump(100); setStatus('Done! Download your .DST and palette.txt.','ok');
  }catch(e){console.error(e);setStatus('Processing failed. Try a simpler image.','error');}
  finally{processBtn.disabled=false; setTimeout(()=>bump(0),1200);}
};

/* ===== misc ===== */
function applyMode(){$('#adv').style.display=$('#autoMode').checked?'none':'flex';}
applyMode(); $('#autoMode').onchange=applyMode;
$('#manualColors').classList.toggle('hidden',$('#autoColors').checked);
sizeOut.textContent=sizePctRange.value+'%';
</script>
</body>
</html>